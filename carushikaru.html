<!DOCTYPE html>
<html lang="te">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>తెలుగు పదాల వేట (Telugu Word Racer)</title>
    <style>
        :root {
            --primary-text-color: #eef0f1;
            --highlight-color: #f1c40f; /* Gold */
            --accent-color: #3498db; /* Blue */
            --danger-color: #e74c3c; /* Red */
            --success-color: #2ecc71; /* Green */
            --bg-dark: #232931;
            --bg-medium: #393e46;
            --bg-light: #4a5568;
            --road-color: #6c7a89;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }

        body {
            margin: 0;
            font-family: 'Noto Sans Telugu', Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--primary-text-color);
            display: flex; /* For centering appWrapper if it has a max-width */
            justify-content: center;
            align-items: center;
            height: 100vh; /* Fallback for older browsers */
            height: 100dvh; /* Dynamic viewport height, better for mobile toolbars */
            overflow: hidden; /* Prevent body scroll */
        }

        #appWrapper {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            max-width: 500px; /* Max width for very wide screens, game scales within */
            margin: 0 auto; /* Center if max-width is applied */
            background-color: var(--bg-dark); /* Match body */
            overflow: hidden; /* Important to contain content */
        }

        #uiContainer {
            width: 100%;
            padding: clamp(8px, 2vh, 12px) 0; /* Responsive padding */
            background: linear-gradient(to bottom, rgba(44, 62, 80, 0.95), rgba(52, 73, 94, 0.9));
            text-align: center;
            z-index: 10;
            border-bottom: 2px solid #2c3e50;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            flex-shrink: 0; /* Prevent this from shrinking */
        }

        #wordDisplay {
            font-size: clamp(20px, 5vw, 30px); /* Responsive font size */
            margin-bottom: clamp(4px, 1vh, 8px);
            letter-spacing: 2px;
            color: var(--highlight-color);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            padding: 0 10px; /* Prevent text touching edges */
            word-break: break-all; /* In case a very long word is displayed */
        }
        .highlight {
            color: var(--success-color);
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }
        #statsDisplay {
            font-size: clamp(14px, 3.5vw, 18px);
            color: #bdc3c7;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
        }
        #statsDisplay span {
            color: #ffffff;
            font-weight: bold;
        }

        #gameContainer {
            flex-grow: 1; /* Takes up available vertical space */
            width: 100%;
            position: relative; /* For overlays and warning message */
            overflow: hidden; /* Crucial for canvas aspect ratio */
            background-color: var(--bg-medium); /* Visible if canvas aspect ratio differs */
            display: flex; /* To center canvas */
            justify-content: center;
            align-items: center;
            border-radius: 0; /* If appWrapper controls outer look */
            /* Original border was on gameContainer, if desired:
            border-left: 2px solid var(--bg-light);
            border-right: 2px solid var(--bg-light);
            */
        }
        canvas {
            display: block;
            background-color: var(--road-color); /* Road color */
            max-width: 100%;
            max-height: 100%;
            /* aspect-ratio: attr(width) / attr(height); */ /* Modern way, but max-width/height is fine */
            object-fit: contain; /* Ensures aspect ratio is maintained */
        }

        .messageOverlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(30, 30, 40, 0.9); /* Slightly more opaque */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
            color: white;
            padding: clamp(15px, 4vw, 20px);
        }
        .messageOverlay h1 {
            font-size: clamp(28px, 7vw, 36px);
            color: var(--highlight-color);
            margin-bottom: clamp(10px, 2vh, 15px);
            text-shadow: 2px 2px 3px rgba(0,0,0,0.5);
        }
         .messageOverlay h2 { /* For Game Over */
            font-size: clamp(26px, 6.5vw, 32px);
            color: var(--danger-color);
            margin-bottom: clamp(10px, 2vh, 15px);
            text-shadow: 2px 2px 3px rgba(0,0,0,0.5);
        }
        .messageOverlay p {
            font-size: clamp(14px, 3.5vw, 18px);
            line-height: 1.5;
            margin-bottom: clamp(8px, 1.5vh, 10px);
        }
        .messageOverlay button {
            padding: clamp(10px, 3vh, 14px) clamp(20px, 5vw, 30px);
            font-size: clamp(16px, 4vw, 20px);
            margin-top: clamp(15px, 3vh, 25px);
            cursor: pointer;
            background: linear-gradient(to bottom, var(--accent-color), #2980b9);
            border: 1px solid #2980b9;
            color: white;
            border-radius: 8px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
            touch-action: manipulation; /* Improve touch responsiveness */
        }
        .messageOverlay button:hover {
            background: linear-gradient(to bottom, #2980b9, var(--accent-color));
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
            transform: translateY(-2px);
        }
        .messageOverlay button:active {
            transform: translateY(0px);
            box-shadow: 0 2px 3px rgba(0,0,0,0.2);
        }
        .hidden { display: none !important; } /* Use !important to override inline styles if any (though not ideal) */

        #warningMessage {
            position: absolute;
            top: 10%; /* Closer to top of game area */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(231, 76, 60, 0.9);
            color: white;
            padding: clamp(8px, 2vw, 12px) clamp(15px, 4vw, 20px);
            border-radius: 8px;
            font-size: clamp(13px, 3vw, 17px);
            font-weight: bold;
            z-index: 15;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            box-shadow: 0 3px 7px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
            pointer-events: none; /* Don't intercept clicks */
        }
        #warningMessage.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0); /* No extra Y movement needed */
        }

        #controlsContainer {
            width: 100%;
            padding: clamp(8px, 2vh, 12px);
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: rgba(44, 62, 80, 0.85); /* Match UI panel */
            border-top: 2px solid #2c3e50;
            flex-shrink: 0; /* Prevent shrinking */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
        }
        #controlsContainer button {
            font-size: clamp(22px, 6vw, 32px); /* Larger symbols */
            padding: clamp(8px, 2vh, 12px) clamp(25px, 7vw, 40px); /* Wider buttons */
            min-width: clamp(70px, 20vw, 100px); /* Ensure good tap area */
            background-color: var(--accent-color);
            color: white;
            border: 1px solid #2980b9;
            border-radius: 8px;
            cursor: pointer;
            touch-action: manipulation; /* Crucial for responsive touch */
            font-weight: bold;
        }
        #controlsContainer button:active {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <div id="appWrapper">
        <div id="uiContainer">
            <div id="wordDisplay"></div>
            <div id="statsDisplay">
                Level: <span id="level">1</span> | Lives: <span id="lives">3</span>
            </div>
        </div>

        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div id="warningMessage">తప్పు అక్షరం లేదా అడ్డంకిని తాకారు, జాగ్రత్త!</div>
            <div id="startScreen" class="messageOverlay">
                <h1>తెలుగు పదాల వేట</h1>
                <p>రోడ్డుపై సరైన తెలుగు అక్షరాలను సేకరించి పదాన్ని పూర్తి చేయండి.</p>
                <p>అడ్డంకులను మరియు తప్పు అక్షరాలను తాకొద్దు!</p>
                <p id="controlInstructionsP">Use ARROW KEYS or A/D to move.</p>
                <button id="startButton">Start Game</button>
            </div>
            <div id="gameOverScreen" class="messageOverlay hidden">
                <h2 id="gameOverMessage">Game Over!</h2>
                <p>ఆట ముగిసింది!</p>
                <button id="restartButton">Play Again</button>
            </div>
        </div>

        <div id="controlsContainer">
            <button id="btnLeft" aria-label="Move Left">◀</button>
            <button id="btnRight" aria-label="Move Right">▶</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // const gameContainer = document.getElementById('gameContainer'); // No longer needed for sizing
        const wordDisplay = document.getElementById('wordDisplay');
        const livesDisplay = document.getElementById('lives');
        const levelDisplay = document.getElementById('level');
        const warningMessageElement = document.getElementById('warningMessage');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const controlInstructionsP = document.getElementById('controlInstructionsP');

        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');

        const GAME_WIDTH = 400; // Internal game resolution
        const GAME_HEIGHT = 600; // Internal game resolution
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;
        // REMOVED: gameContainer.style.width and height settings

        const TELUGU_WORDS = [
            { word: "పలక", meaning: "Slate" }, { word: "నగ", meaning: "Jewel" },
            { word: "గడప", meaning: "Threshold" }, { word: "అరక", meaning: "Plough" },
            { word: "వంద", meaning: "Hundred" }, { word: "పడవ", meaning: "Boat" },
            { word: "సహజం", meaning: "Natural" }, { word: "ఆలయం", meaning: "Temple" },
            { word: "విజయం", meaning: "Victory" }, { word: "ప్రపంచం", meaning: "World" }
        ];
        const ALL_TELUGU_CHARS = [
            'అ', 'ఆ', 'ఇ', 'ఈ', 'ఉ', 'ఊ', 'ఋ', 'ఎ', 'ఏ', 'ఐ', 'ఒ', 'ఓ', 'ఔ', 'క', 'ఖ', 'గ', 'ఘ', 'ఙ',
            'చ', 'ఛ', 'జ', 'ఝ', 'ఞ', 'ట', 'ఠ', 'డ', 'ఢ', 'ణ', 'త', 'థ', 'ద', 'ధ', 'న',
            'ప', 'ఫ', 'బ', 'భ', 'మ', 'య', 'ర', 'ల', 'వ', 'శ', 'ష', 'స', 'హ', 'ళ', 'క్ష', 'ఱ',
            'ం', 'ః', 'ా', 'ి', 'ీ', 'ు', 'ూ', 'ృ', 'ె', 'ే', 'ై', 'ొ', 'ో', 'ౌ', '్'
        ];

        let player, road, obstacles, letters, currentWordData;
        let lives, currentLevel, baseSpeed;
        let gameRunning = false;
        let animationFrameId;
        let warningTimeoutId = null;

        const PLAYER_WIDTH = 40;
        const PLAYER_HEIGHT = 55;
        const PLAYER_COLOR = '#3498db';
        const PLAYER_ACCENT_COLOR = '#2980b9';
        const PLAYER_WHEEL_COLOR = '#333';

        const OBSTACLE_COLOR = '#c0392b';
        const OBSTACLE_BORDER_COLOR = '#a12f23';

        const LETTER_COLOR = '#f1c40f';
        const LETTER_SHADOW_COLOR = 'rgba(0,0,0,0.3)';

        class Player {
            constructor() {
                this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT;
                this.x = GAME_WIDTH / 2 - this.width / 2; this.y = GAME_HEIGHT - this.height - 20;
                this.speed = 5.5; this.color = PLAYER_COLOR;
            }
            draw() {
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = PLAYER_ACCENT_COLOR; ctx.fillRect(this.x + 5, this.y - 8, this.width - 10, 10);
                ctx.beginPath(); ctx.moveTo(this.x+5, this.y); ctx.lineTo(this.x+8, this.y-8);
                ctx.lineTo(this.x+this.width-8, this.y-8); ctx.lineTo(this.x+this.width-5, this.y);
                ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#aed6f1'; ctx.beginPath(); ctx.moveTo(this.x + 7, this.y + 5);
                ctx.lineTo(this.x + 10, this.y - 2); ctx.lineTo(this.x + this.width - 10, this.y - 2);
                ctx.lineTo(this.x + this.width - 7, this.y + 5); ctx.closePath(); ctx.fill();
                const wheelWidth = 8; const wheelHeight = 18; ctx.fillStyle = PLAYER_WHEEL_COLOR;
                ctx.fillRect(this.x - wheelWidth/2 +2, this.y + 8, wheelWidth, wheelHeight);
                ctx.fillRect(this.x + this.width - wheelWidth/2 -2, this.y + 8, wheelWidth, wheelHeight);
                ctx.fillRect(this.x - wheelWidth/2 +2, this.y + this.height - wheelHeight - 5, wheelWidth, wheelHeight);
                ctx.fillRect(this.x + this.width - wheelWidth/2 -2, this.y + this.height - wheelHeight - 5, wheelWidth, wheelHeight);
            }
            move(direction) {
                if (direction === 'left') this.x -= this.speed;
                else if (direction === 'right') this.x += this.speed;
                if (this.x < 5) this.x = 5;
                if (this.x + this.width > GAME_WIDTH - 5) this.x = GAME_WIDTH - this.width - 5;
            }
        }
        class Road {
            constructor() {
                this.stripeHeight = 50; this.stripeGap = 30; this.stripeWidth = 12;
                this.stripeColor = 'rgba(255, 255, 255, 0.8)'; this.stripes = []; this.offset = 0;
                for (let i = 0; i < Math.ceil(GAME_HEIGHT / (this.stripeHeight + this.stripeGap)) + 2; i++) {
                    this.stripes.push(i * (this.stripeHeight + this.stripeGap));
                }
            }
            update(speed) { this.offset = (this.offset + speed * 1.2) % (this.stripeHeight + this.stripeGap); }
            draw() {
                for (let i = 0; i < this.stripes.length; i++) {
                    const yPos = this.stripes[i] - this.offset;
                    ctx.fillStyle = this.stripeColor;
                    ctx.fillRect(GAME_WIDTH / 2 - this.stripeWidth / 2, yPos, this.stripeWidth, this.stripeHeight);
                }
                ctx.fillStyle = '#f39c12'; ctx.fillRect(15, 0, 8, GAME_HEIGHT);
                ctx.fillRect(GAME_WIDTH - 15 - 8, 0, 8, GAME_HEIGHT);
            }
        }
        class Obstacle {
            constructor(x, y, width, height, color) {
                this.x = x; this.y = y; this.width = width; this.height = height; this.color = color;
                this.borderColor = OBSTACLE_BORDER_COLOR;
            }
            draw() {
                ctx.fillStyle = this.borderColor; ctx.fillRect(this.x - 1, this.y - 1, this.width + 2, this.height + 2);
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            update(speed) { this.y += speed; }
        }
        class Letter {
            constructor(char, x, y, isTarget) {
                this.char = char; this.x = x; this.y = y; this.size = 32;
                this.width = 30; this.height = 30; this.color = LETTER_COLOR; this.isTarget = isTarget;
            }
            draw() {
                ctx.font = `bold ${this.size}px 'Noto Sans Telugu'`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowColor = LETTER_SHADOW_COLOR; ctx.shadowBlur = 3; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;
                ctx.fillStyle = this.color; ctx.fillText(this.char, this.x + this.width / 2, this.y + this.height / 2 + 3);
                ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
            }
            update(speed) { this.y += speed; }
        }

        function initGame() {
            player = new Player(); road = new Road(); obstacles = []; letters = [];
            lives = 3; currentLevel = 0; baseSpeed = 3;
            startScreen.classList.add('hidden'); gameOverScreen.classList.add('hidden');
            warningMessageElement.classList.remove('visible');
            if(warningTimeoutId) clearTimeout(warningTimeoutId);
            startNextLevel();
            if (!gameRunning) { gameRunning = true; mainGameLoop(); }
        }
        function startNextLevel() {
            currentLevel++;
            if (currentLevel > TELUGU_WORDS.length) { winGame(); return; }
            const wordInfo = TELUGU_WORDS[currentLevel - 1];
            currentWordData = {
                word: wordInfo.word, meaning: wordInfo.meaning,
                lettersToCollect: wordInfo.word.split(''),
                collectedStatus: Array(wordInfo.word.length).fill(false)
            };
            baseSpeed = 2.5 + (currentLevel - 1) * 0.8;
            obstacles = []; letters = []; updateUIDisplay();
        }
        function winGame() {
            gameRunning = false; cancelAnimationFrame(animationFrameId);
            gameOverMessage.innerHTML = `Congratulations! <br>అభినందనలు! <br>You completed all ${TELUGU_WORDS.length} words!`;
            gameOverScreen.classList.remove('hidden');
        }
        function showWarningMessage() {
            if (warningTimeoutId) clearTimeout(warningTimeoutId);
            warningMessageElement.classList.add('visible');
            warningTimeoutId = setTimeout(() => {
                warningMessageElement.classList.remove('visible');
                warningTimeoutId = null;
            }, 1800);
        }
        function loseLife() { lives--; updateUIDisplay(); showWarningMessage(); if (lives <= 0) gameOver(); }
        function gameOver() {
            gameRunning = false; cancelAnimationFrame(animationFrameId);
            gameOverMessage.innerHTML = `Game Over! <br> ఆట ముగిసింది! <br> Level Reached: ${currentLevel}`;
            gameOverScreen.classList.remove('hidden');
        }

        let obstacleSpawnTimer = 0; const OBSTACLE_SPAWN_INTERVAL = 95;
        let letterSpawnTimer = 0; const LETTER_SPAWN_INTERVAL = 75;

        function spawnObstacle() {
            const obstacleWidth = Math.random() * 25 + 30; const obstacleHeight = Math.random() * 25 + 20;
            const laneWidth = GAME_WIDTH / 3; const lane = Math.floor(Math.random() * 3);
            const x = (lane * laneWidth) + (laneWidth / 2) - (obstacleWidth / 2);
            obstacles.push(new Obstacle(x, -obstacleHeight, obstacleWidth, obstacleHeight, OBSTACLE_COLOR));
        }
        function spawnLetter() {
            let char; let isTargetLetter = false; const uncollectedTargetLetters = [];
            currentWordData.lettersToCollect.forEach((letterChar, index) => {
                if (!currentWordData.collectedStatus[index]) uncollectedTargetLetters.push(letterChar);
            });
            if (uncollectedTargetLetters.length > 0 && Math.random() < 0.7) {
                char = uncollectedTargetLetters[Math.floor(Math.random() * uncollectedTargetLetters.length)];
                isTargetLetter = true;
            } else {
                char = ALL_TELUGU_CHARS[Math.floor(Math.random() * ALL_TELUGU_CHARS.length)];
                isTargetLetter = uncollectedTargetLetters.includes(char); // Could still be a target by chance
            }
            const letterSize = 30; const x = Math.random() * (GAME_WIDTH - letterSize - 30) + 15;
            letters.push(new Letter(char, x, -letterSize, isTargetLetter));
        }
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }
        function updateUIDisplay() {
            let displayString = "";
            currentWordData.lettersToCollect.forEach((char, index) => {
                displayString += `<span class="${currentWordData.collectedStatus[index] ? 'highlight' : ''}">${char}</span>`;
            });
            wordDisplay.innerHTML = displayString;
            livesDisplay.textContent = lives; levelDisplay.textContent = currentLevel;
        }
        function mainGameLoop() {
            if (!gameRunning) return;
            handleInput(); ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            road.update(baseSpeed); road.draw(); player.draw();
            const speedFactor = baseSpeed / 2.5;
            obstacleSpawnTimer++; if (obstacleSpawnTimer > OBSTACLE_SPAWN_INTERVAL / speedFactor) { spawnObstacle(); obstacleSpawnTimer = 0; }
            letterSpawnTimer++; if (letterSpawnTimer > LETTER_SPAWN_INTERVAL / speedFactor) { spawnLetter(); letterSpawnTimer = 0; }
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i]; obs.update(baseSpeed); obs.draw();
                if (checkCollision(player, obs)) { obstacles.splice(i, 1); loseLife(); }
                else if (obs.y > GAME_HEIGHT) obstacles.splice(i, 1);
            }
            for (let i = letters.length - 1; i >= 0; i--) {
                const letterObj = letters[i]; letterObj.update(baseSpeed); letterObj.draw();
                if (checkCollision(player, letterObj)) {
                    let letterWasNeededAndCorrectlyCollected = false;
                    if (letterObj.isTarget) {
                        const firstNeededIndex = currentWordData.lettersToCollect.findIndex(
                            (targetChar, idx) => targetChar === letterObj.char && !currentWordData.collectedStatus[idx]
                        );
                        if (firstNeededIndex !== -1) {
                            currentWordData.collectedStatus[firstNeededIndex] = true;
                            letterWasNeededAndCorrectlyCollected = true; updateUIDisplay();
                            if (currentWordData.collectedStatus.every(status => status === true)) {
                                setTimeout(() => { if(gameRunning) startNextLevel(); }, 600);
                            }
                        }
                    }
                    if (!letterWasNeededAndCorrectlyCollected) loseLife();
                    letters.splice(i, 1);
                } else if (letterObj.y > GAME_HEIGHT) letters.splice(i, 1);
            }
            animationFrameId = requestAnimationFrame(mainGameLoop);
        }

        const keyState = {};
        window.addEventListener('keydown', (e) => {
            keyState[e.key] = true; // For 'a' and 'd' as well
            if (gameRunning && (e.key === "ArrowLeft" || e.key === "ArrowRight")) { // Only prevent default for arrows if game is running
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', (e) => { keyState[e.key] = false; });

        function handleInput(){
            if (!gameRunning) return;
            if (keyState['ArrowLeft'] || keyState['a'] || keyState['A']) player.move('left');
            if (keyState['ArrowRight'] || keyState['d'] || keyState['D']) player.move('right');
        }

        // Touch Controls
        function handleTouch(event, key, isPressed) {
            event.preventDefault();
            keyState[key] = isPressed;
        }
        btnLeft.addEventListener('touchstart', (e) => handleTouch(e, 'ArrowLeft', true));
        btnLeft.addEventListener('touchend', (e) => handleTouch(e, 'ArrowLeft', false));
        btnLeft.addEventListener('touchcancel', (e) => handleTouch(e, 'ArrowLeft', false)); // Handle unexpected touch end

        btnRight.addEventListener('touchstart', (e) => handleTouch(e, 'ArrowRight', true));
        btnRight.addEventListener('touchend', (e) => handleTouch(e, 'ArrowRight', false));
        btnRight.addEventListener('touchcancel', (e) => handleTouch(e, 'ArrowRight', false));

        startButton.addEventListener('click', initGame);
        restartButton.addEventListener('click', initGame);

        window.onload = () => {
            startScreen.classList.remove('hidden');
            warningMessageElement.classList.remove('visible');
            // REMOVED: document.getElementById('uiContainer').style.width setting

            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
            if (controlInstructionsP) {
                controlInstructionsP.textContent = isTouchDevice ? "Use ON-SCREEN BUTTONS to move." : "Use ARROW KEYS or A/D to move.";
            }
            // Hide on-screen controls if not a touch device (optional)
            if (!isTouchDevice) {
                document.getElementById('controlsContainer').style.display = 'none';
            }
        };
    </script>
</body>
</html>
